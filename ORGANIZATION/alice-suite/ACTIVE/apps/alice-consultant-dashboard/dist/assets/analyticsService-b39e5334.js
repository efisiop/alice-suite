var f=Object.defineProperty;var S=(t,i,e)=>i in t?f(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e;var s=(t,i,e)=>(S(t,typeof i!="symbol"?i+"":i,e),e);import{r as o}from"./App-79293938.js";import{e as n}from"./index-4598f639.js";import"./supabaseClient-27bb94ef.js";const l={authService:[],bookService:["authService"],dictionaryService:["bookService"],aiService:["bookService","dictionaryService"],feedbackService:["authService","bookService"],triggerService:["authService","bookService"],statisticsService:["bookService","authService"],consultantService:["authService","bookService","feedbackService","triggerService"],interactionService:["authService","bookService"],monitoringService:[],databaseService:["authService"],analyticsService:[],sampleService:["bookService"]};function g(){const t=new Set,i=[],e=new Set;function r(c){if(e.has(c)){const a=Array.from(e).join(" -> ")+` -> ${c}`;n("InitOrder",`Circular dependency detected: ${a}`,"error"),console.error(`Circular dependency detected: ${a}`);return}if(t.has(c))return;e.add(c);const v=l[c]||[];for(const a of v)r(a);t.add(c),e.delete(c),i.push(c)}for(const c of Object.keys(l))t.has(c)||r(c);return n("InitOrder",`Initialization order: ${i.join(", ")}`,"info"),i}class d{constructor(){s(this,"initFunctions",new Map);s(this,"dependencies",new Map);s(this,"initialized",new Set);s(this,"initializing",new Set)}register(i,e,r){console.log(`Registering initialization function for ${i}`),this.initFunctions.set(i,e);const c=r||l[i]||[];this.dependencies.set(i,c),n("ServiceInitManager",`Registered initialization function for ${i}`,"info"),console.log(`Available services for initialization: ${Array.from(this.initFunctions.keys()).join(", ")}`)}async initializeService(i){if(console.log(`Attempting to initialize service: ${i}`),this.initialized.has(i)){n("ServiceInitManager",`Service ${i} already initialized`,"info"),console.log(`Service ${i} already initialized`);return}if(this.initializing.has(i)){n("ServiceInitManager",`Circular initialization detected for service: ${i}`,"warning"),console.warn(`Circular initialization detected for service: ${i}`);return}if(!this.initFunctions.has(i))throw console.error(`No initialization function registered for service: ${i}`),console.error(`Available services: ${Array.from(this.initFunctions.keys()).join(", ")}`),n("ServiceInitManager",`No initialization function registered for service: ${i}`,"error"),new Error(`No initialization function registered for service: ${i}`);n("ServiceInitManager",`Initializing service: ${i}`,"info"),console.log(`Initializing service: ${i}`),this.initializing.add(i);const e=this.dependencies.get(i)||[];for(const r of e)await this.initializeService(r);try{console.log(`Executing initialization function for ${i}`),await this.initFunctions.get(i)(),this.initialized.add(i),n("ServiceInitManager",`Service ${i} initialized successfully`,"success"),console.log(`Service ${i} initialized successfully`)}catch(r){throw n("ServiceInitManager",`Error initializing service ${i}: ${r.message}`,"error"),console.error(`Error initializing service ${i}:`,r),r}finally{this.initializing.delete(i)}}async initializeAll(i={}){n("ServiceInitManager","Initializing all services","info"),console.log("Initializing all services");let e;i.useTopologicalOrder?(e=g().filter(r=>this.initFunctions.has(r)),n("ServiceInitManager",`Using topological order: ${e.join(", ")}`,"info")):(e=Array.from(this.initFunctions.keys()),n("ServiceInitManager",`Using registration order: ${e.join(", ")}`,"info")),console.log(`Services to initialize: ${e.join(", ")}`);for(const r of e)await this.initializeService(r);n("ServiceInitManager","All services initialized successfully","success"),console.log("All services initialized successfully")}isInitialized(i){return this.initialized.has(i)}getInitializedServices(){return Array.from(this.initialized)}hasInitFunction(i){return this.initFunctions.has(i)}getRegisteredServices(){return Array.from(this.initFunctions.keys())}}const y=new d,u=async()=>(n("AnalyticsService","Creating analytics service","info"),{identifyUser:(i,e={})=>{try{n("AnalyticsService",`Identify user: ${i}`,"info",e)}catch(r){n("AnalyticsService","Error identifying user","error",r)}},resetUser:()=>{try{n("AnalyticsService","Reset user","info")}catch(i){n("AnalyticsService","Error resetting user","error",i)}},trackEvent:(i,e={})=>{try{n("AnalyticsService",`Track event: ${i}`,"info",e)}catch(r){n("AnalyticsService","Error tracking event","error",r)}},trackPageView:(i,e={})=>{try{n("AnalyticsService",`Page view: ${i}`,"info",e)}catch(r){n("AnalyticsService","Error tracking page view","error",r)}},trackReaderAction:(i,e)=>{try{n("AnalyticsService",`Reader action: ${i}`,"info",e)}catch(r){n("AnalyticsService","Error tracking reader action","error",r)}},trackPerformance:(i,e,r={})=>{try{n("AnalyticsService",`Performance ${i}: ${e}ms`,"info",r)}catch(c){n("AnalyticsService","Error tracking performance","error",c)}}});y.register("analyticsService",async()=>{const t=await u();o.register("analyticsService",t)});const h=(t,i)=>{const e=o.get("analyticsService");e&&e.identifyUser(t,i)},z=()=>{const t=o.get("analyticsService");t&&t.resetUser()},k=(t,i)=>{const e=o.get("analyticsService");e&&e.trackEvent(t,i)},$=(t,i)=>{const e=o.get("analyticsService");e&&e.trackPageView(t,i)},A=(t,i)=>{const e=o.get("analyticsService");e&&e.trackReaderAction(t,i)},p=(t,i,e)=>{const r=o.get("analyticsService");r&&r.trackPerformance(t,i,e)},b={identifyUser:h,resetUser:z,trackEvent:k,trackPageView:$,trackReaderAction:A,trackPerformance:p};export{u as createAnalyticsService,b as default,h as identifyUser,z as resetUser,k as trackEvent,$ as trackPageView,p as trackPerformance,A as trackReaderAction};
