var d=Object.defineProperty;var v=(o,i,e)=>i in o?d(o,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):o[i]=e;var c=(o,i,e)=>(v(o,typeof i!="symbol"?i+"":i,e),e);import{d as n}from"./index-a2a96a2b.js";const a={authService:[],bookService:["authService"],dictionaryService:["bookService"],aiService:["bookService","dictionaryService"],feedbackService:["authService","bookService"],triggerService:["authService","bookService"],statisticsService:["bookService","authService"],consultantService:["authService","bookService","feedbackService","triggerService"],interactionService:["authService","bookService"],monitoringService:[],databaseService:["authService"],analyticsService:[],sampleService:["bookService"]};function g(){const o=new Set,i=[],e=new Set;function r(t){if(e.has(t)){const s=Array.from(e).join(" -> ")+` -> ${t}`;n("InitOrder",`Circular dependency detected: ${s}`,"error"),console.error(`Circular dependency detected: ${s}`);return}if(o.has(t))return;e.add(t);const l=a[t]||[];for(const s of l)r(s);o.add(t),e.delete(t),i.push(t)}for(const t of Object.keys(a))o.has(t)||r(t);return n("InitOrder",`Initialization order: ${i.join(", ")}`,"info"),i}class S{constructor(){c(this,"initFunctions",new Map);c(this,"dependencies",new Map);c(this,"initialized",new Set);c(this,"initializing",new Set)}register(i,e,r){console.log(`Registering initialization function for ${i}`),this.initFunctions.set(i,e);const t=r||a[i]||[];this.dependencies.set(i,t),n("ServiceInitManager",`Registered initialization function for ${i}`,"info"),console.log(`Available services for initialization: ${Array.from(this.initFunctions.keys()).join(", ")}`)}async initializeService(i){if(console.log(`Attempting to initialize service: ${i}`),this.initialized.has(i)){n("ServiceInitManager",`Service ${i} already initialized`,"info"),console.log(`Service ${i} already initialized`);return}if(this.initializing.has(i)){n("ServiceInitManager",`Circular initialization detected for service: ${i}`,"warning"),console.warn(`Circular initialization detected for service: ${i}`);return}if(!this.initFunctions.has(i))throw console.error(`No initialization function registered for service: ${i}`),console.error(`Available services: ${Array.from(this.initFunctions.keys()).join(", ")}`),n("ServiceInitManager",`No initialization function registered for service: ${i}`,"error"),new Error(`No initialization function registered for service: ${i}`);n("ServiceInitManager",`Initializing service: ${i}`,"info"),console.log(`Initializing service: ${i}`),this.initializing.add(i);const e=this.dependencies.get(i)||[];for(const r of e)await this.initializeService(r);try{console.log(`Executing initialization function for ${i}`),await this.initFunctions.get(i)(),this.initialized.add(i),n("ServiceInitManager",`Service ${i} initialized successfully`,"success"),console.log(`Service ${i} initialized successfully`)}catch(r){throw n("ServiceInitManager",`Error initializing service ${i}: ${r.message}`,"error"),console.error(`Error initializing service ${i}:`,r),r}finally{this.initializing.delete(i)}}async initializeAll(i={}){n("ServiceInitManager","Initializing all services","info"),console.log("Initializing all services");let e;i.useTopologicalOrder?(e=g().filter(r=>this.initFunctions.has(r)),n("ServiceInitManager",`Using topological order: ${e.join(", ")}`,"info")):(e=Array.from(this.initFunctions.keys()),n("ServiceInitManager",`Using registration order: ${e.join(", ")}`,"info")),console.log(`Services to initialize: ${e.join(", ")}`);for(const r of e)await this.initializeService(r);n("ServiceInitManager","All services initialized successfully","success"),console.log("All services initialized successfully")}isInitialized(i){return this.initialized.has(i)}getInitializedServices(){return Array.from(this.initialized)}hasInitFunction(i){return this.initFunctions.has(i)}getRegisteredServices(){return Array.from(this.initFunctions.keys())}}const h=new S;export{h as i};
